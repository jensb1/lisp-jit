#!/usr/bin/env node
// Bootstrap Driver - Runs Lisp source compiled by the Lisp compiler
// This creates a complete self-hosting cycle

import * as fs from 'fs';
import { parse } from './parser';
import { JitCodeGenerator } from './jit-codegen';
import { JitExecutor } from './jit';

// Create a Lisp program that compiles another Lisp program
function createCompilerProgram(sourceFile: string, printStrAddr: bigint): string {
  const source = fs.readFileSync(sourceFile, 'utf-8');
  // Escape the source for embedding
  const escaped = source.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');

  return `
; Bootstrap compilation - compile and output bytes

; First, include the bootstrap compiler code
${fs.readFileSync('lisp/bootstrap.lisp', 'utf-8')}

; Now compile the target source
(define target-source "${escaped}")
(define target-tokens (tokenize target-source))
(define target-ast (parse target-tokens))

; Create codegen and compile
(define target-cg (make-codegen))
(compile-program target-cg target-ast ${printStrAddr}n)

; Output the generated bytes
(output-bytes target-cg)
`;
}

// Simpler approach: Just run a test program through the Lisp compiler
async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('Bootstrap Driver - Self-hosting Lisp Compiler');
    console.log('');
    console.log('Usage: npx ts-node src/bootstrap-driver.ts <source.lisp>');
    console.log('');
    console.log('This compiles Lisp source using the Lisp compiler and executes the result.');
    process.exit(0);
  }

  const sourceFile = args[0];
  if (!fs.existsSync(sourceFile)) {
    console.error(`File not found: ${sourceFile}`);
    process.exit(1);
  }

  console.log(`Compiling ${sourceFile} with Lisp bootstrap compiler...`);

  // Set up JIT executor to get runtime addresses
  const executor = new JitExecutor();
  executor.allocate(4 * 1024 * 1024, 64 * 1024 * 1024);
  const addresses = executor.getAddresses();

  // Read the source file
  const source = fs.readFileSync(sourceFile, 'utf-8');

  // First, compile and run the bootstrap compiler to generate code for our source
  // We'll use the TypeScript compiler to bootstrap the Lisp compiler first

  // Step 1: Parse the bootstrap compiler + target source
  const bootstrapSource = fs.readFileSync('lisp/bootstrap.lisp', 'utf-8');

  // Create a program that:
  // 1. Defines the compile-file function (from bootstrap.lisp)
  // 2. Compiles our target source
  // 3. Outputs the bytes

  const combinedSource = `
${bootstrapSource}

; Target source to compile
(define target-source "${source.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}")

; Compile it
(define target-tokens (tokenize target-source))
(define target-ast (parse target-tokens))
(define target-cg (make-codegen))
(compile-program target-cg target-ast ${addresses.printStr})
(output-bytes target-cg)
`;

  try {
    // Parse and compile the combined program using TypeScript JIT
    const ast = parse(combinedSource);
    const codegen = new JitCodeGenerator(addresses);
    const code = codegen.generate(ast);

    // Execute to get the output (bytes printed to stdout)
    executor.write(code);

    // Capture stdout
    const oldLog = console.log;
    const output: number[] = [];
    let capturing = false;
    let byteCount = 0;
    let bytesRead = 0;

    console.log = (...args: unknown[]) => {
      const val = Number(args[0]);
      if (!capturing && !isNaN(val) && val > 0) {
        // First number is byte count
        byteCount = val;
        capturing = true;
      } else if (capturing && bytesRead < byteCount) {
        output.push(val);
        bytesRead++;
      } else {
        oldLog.apply(console, args);
      }
    };

    executor.execute();
    console.log = oldLog;

    if (output.length === 0) {
      console.log('No code generated - checking for errors...');
      executor.free();
      process.exit(1);
    }

    console.log(`Generated ${output.length} bytes of machine code`);

    // Now execute the generated code
    const generatedCode = new Uint8Array(output);

    // Create new executor for the generated code
    const executor2 = new JitExecutor();
    executor2.allocate(1024 * 1024, 64 * 1024 * 1024);
    executor2.write(generatedCode);

    console.log('Executing generated code...');
    console.log('---');
    const result = executor2.execute();
    console.log('---');
    console.log(`Result: ${result}`);

    executor.free();
    executor2.free();

  } catch (e) {
    console.error('Compilation error:', (e as Error).message);
    executor.free();
    process.exit(1);
  }
}

main();
